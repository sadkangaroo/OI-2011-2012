#include<iostream>
#include<string>
#include<math.h>
#include<queue>
#include<vector>
using namespace std;

long n,ans,tmp;

/*
 哈夫曼树又称最优二叉树，是把n个给定的权值作为叶子节点的所有二叉树中带权路径和（WLP）最小的一个
 所谓带权路径和就是sigma(叶子节点的权值*叶子节点到根的距离)
 首先可以证明，哈夫曼树的每个非叶子节点都有两个儿子（不然可以调整使WLP变小）
 其次由排序不等式可以证明，权值越小的叶子节点到根节点的距离越长，
 从而可以给出一种构造哈夫曼树的方法 :
 初始时每个权值为一颗只有一个节点的树的根节点，
 然后每次选取权值最小的两个根节点分别作为一棵树的左右儿子，这棵树的根节点为左右儿子权值之和，
 将这棵树加入集合中，刚刚选取的两棵树去除集合 
 这样进行n-1次就构造了一颗哈夫曼树
 证明： 
 设对于的n+1个叶节点权值，有一颗哈夫曼树T(n+1),则到根节点距离最长的叶节点中必然包含了权值最小的两个节点w1,w2 
 将这两个节点合并为w，得到一棵树H(n)，设以H(n)叶节点权值为叶节点权值的哈夫曼树为T(n)，
 再设将T(n)中w分裂成w1,w2得到的树为H(n+1);
 设树x的带权路径和为L(x)
 则有 H(n)+w1+s2=T(n+1)
      T(n)+w1+w2=H(n+1)
      因为T(n+1)<=H(n+1),所以H(n)<=T(n) 而由定义得 H(n)>=T(n)，所以 H(n)=T(n)
      所以H(n)也为一颗哈夫曼树
  由数学归纳法得，如此构造n-1次之后可构造出一颗哈夫曼树
  带权路径和最大的树不存在 
  而每个非叶子节点都有两个儿子的带权路径和最大的树存在，且构造方法与证明方法类似 
  合并果子与木板风格的方法实际上都对应一颗哈夫曼树，因此都可以用哈夫曼树解决
  哈夫曼树的构造只要用堆(或者说优先队列)来实现
*/

int main(){
  priority_queue< long,vector<long>,greater<long> > a;
  ans=0;
  for(long i=1;i<=n-1;++i){
    tmp=a.top();a.pop();
    tmp+=a.top();a.pop();
    ans+=tmp;a.push(tmp);
  } 
  return 0;
}
